import constants as c
import fitness as fit
import population as pop

def operations(new_pop):
	individual = c.ELITISM
	while(individual < c.POPULATION_SIZE):
		method = c.random.randint(1, 100)
		if individual >= (c.POPULATION_SIZE-1): # There is only a individual, and reproduction rate is updated to 1 - 'c.MUTATION_RATE'
			if method < c.MUTATION_RATE: # Mutation
				mutation(new_pop[individual])
				individual = individual + 1
			else: # 
				individual = individual + 1
		else:
			if method <= c.CROSSOVER_RATE: # Crossover
				crossover(new_pop[individual], new_pop[individual+1])
				individual = individual + 2
			elif method <= c.CROSSOVER_RATE + c.MUTATION_RATE: # Mutation
				mutation(new_pop[individual])
				individual = individual + 1
			else: # Reproduction - The pair continous in the population
				individual = individual + 1

################################################ CROSSOVER ######################################################
"""
	This function crossover two individuals, swapping part of their genotypes.
	- At first, the 'commom region' is calculated between the 2 parents. The commom region is
	  the region in the parents trees that have the same shape, starting from the roots.
	- After, the nodes in the commom region (that is another tree) are numbered 
	  from 1 to 'nodes_quantity' in pre order traversal.
	- A random integer is selected, and it represents the crossover point, in both parents trees.
	  The sub-trees in the crossover point are swapped, creating 2 new offsprings.
	- In the total of 4 individuals, the 2 best are selected and returned in 'p1' and 'p2'.
"""

#p1 and p2 are objects of Individual()
def crossover(p1, p2):
	c1, c2 = c.Individual(tree=c.Node(None)), c.Individual(tree=c.Node(None))
	copy_tree(p1.tree, c1.tree)
	copy_tree(p2.tree, c2.tree)

	commom_region = c.Node(0)
	build_commom_region(commom_region, 2)

	nodes_numbers = [0] #Number of nodes;

	set_commom_region(p1.tree, p2.tree, commom_region, nodes_numbers)

	if p1.size > 1 and p2.size > 1:
		crossover_point = c.random.randint(2, nodes_numbers[0])
		swap(c1.tree, c2.tree, commom_region, crossover_point, False)
	else:
		crossover_point = 1
		swap(c1.tree, c2.tree, commom_region, crossover_point, False)

	fit.fitness(c1)
	fit.fitness(c2)

	fitness_values = [p1, p2, c1, c2]
	fitness_values.sort(key=c.operator.attrgetter('fitness'))

	p1, p2 = fitness_values[0], fitness_values[1]

# Copy a tree (from the class c.Node). Input: 2 roots
def copy_tree(original, copy):
	copy.item = original.item
	copy.level = original.level
	if original.left != None:
		copy.left = c.Node(None)
		copy_tree(original.left, copy.left)
	if original.right != None:
		copy.right = c.Node(None)
		copy_tree(original.right, copy.right)

# p1 = parent 1; p2 = parent 2. The trees of parent 1 and 2 must have at least one node
def set_commom_region(p1, p2, commom_region, nodes_numbers):
	nodes_numbers[0] = nodes_numbers[0] + 1
	commom_region.item = nodes_numbers[0]
	if p1.left != None and p2.left != None:
		set_commom_region(p1.left, p2.left, commom_region.left, nodes_numbers)
	if p1.right != None and p2.right != None:
		set_commom_region(p1.right, p2.right, commom_region.right, nodes_numbers)

# Build a complete binary tree, with all nodes until the max depth (c.MAX_DEPTH).
def build_commom_region(node, current_depth):
	if current_depth <= c.MAX_DEPTH:
		node.left = c.Node(0)
		node.right = c.Node(0)
		build_commom_region(node.left, current_depth+1)
		build_commom_region(node.right, current_depth+1)	

#If the crossover point is the root, the swap function would swap the entire trees, so it ins't necessary, just pass both trees
def swap(c1, c2, commom_region, crossover_point, find):
	if not find:
		if commom_region.left != None and commom_region.left.item > 0:
			if commom_region.left.item == crossover_point:
				find = True
				c1.left, c2.left = c2.left, c1.left
			swap(c1.left, c2.left, commom_region.left, crossover_point, find)

		if commom_region.right != None and commom_region.right.item > 0:
			if commom_region.right.item == crossover_point:
				find = True
				c1.right, c2.right = c2.right, c1.right
			swap(c1.right, c2.right, commom_region.right, crossover_point, find)

################################################ MUTATION #######################################################
"""
	It selects a random node in the individual tree to mutate.
	The are 2 kind of mutation:
		- (1) Point mutation
			Swap the choosed node for a new subtree generated by pop.grow or pop.full.
		- (2) Expansion mutation
			Swap the choosed node - which has a terminal - for a new subtree generated by pop.grow or pop.full.
		- (3) Reduction mutation
			Swap the choosed node - which has a function - for one terminal.
	The new individual is returned in 'ind'
"""

# Set levels in the nodes. It's used when a tree is changed, and the new embedded part doesn't have the levels set.
def set_level(tree, level):
	tree.level = level
	if tree.left != None:
		set_level(tree.left, level+1)
	if tree.right != None:
		set_level(tree.right, level+1)

# Set numbers into a tree, in pre order traversal.
def set_numbers_into_copy(node, number):
	number[0] = number[0] + 1
	node.item = number[0]
	if node.left != None:
		set_numbers_into_copy(node.left, number)
	if node.right != None:
		set_numbers_into_copy(node.right, number)

# Counts the number of nodes in a tree, and returns it in 'tree_size'
def calculate_size(node, tree_size):
	tree_size[0] = tree_size[0] + 1
	if node.left != None:
		calculate_size(node.left, tree_size)
	if node.right != None:
		calculate_size(node.right, tree_size)

def mutation(ind):
	mutation_type = c.random.randint(1,3)
	aux_tree = c.Node(0)
	copy_tree(ind.tree, aux_tree)
	set_numbers_into_copy(aux_tree, [0])
	tree_root = c.Node(0, left=ind.tree)
	aux_tree_root = c.Node(0, left=aux_tree)

	new_size = [0]
	if mutation_type == 1: # Point mutation
		mutation_point = c.random.randint(1, ind.size)
		mutate(tree_root, aux_tree_root, mutation_point, 1, False)
		calculate_size(ind.tree, new_size)
		ind.size = new_size[0]
	elif mutation_type == 2: # Expansion mutation
		t_nodes = [] # List of nodes which has a terminal
		terminal_nodes(ind.tree, aux_tree, t_nodes)
		mutation_point = (c.random.sample(t_nodes, 1))[0]
		mutate(tree_root, aux_tree_root, mutation_point, 2, False)
		if tree_root.left != ind.tree:
			ind.tree = tree_root.left
		calculate_size(ind.tree, new_size)
		ind.size = new_size[0]
		set_level(ind.tree, 1)
	else: # == 3, Reduction mutation. If there is only a node (the root), it won't do nothing.
		if ind.size > 1:
			f_nodes = [] # List of nodes which has a function
			function_nodes(ind.tree, aux_tree, f_nodes)
			mutation_point = (c.random.sample(f_nodes, 1))[0]
			mutate(tree_root, aux_tree_root, mutation_point, 3, False)
			if tree_root.left != ind.tree:
				ind.tree = tree_root.left
			calculate_size(ind.tree, new_size)
			ind.size = new_size[0]
	fit.fitness(ind)

# Select the nodes from a tree which have only functions
def function_nodes(node, aux_tree, f_nodes):
	if node.item in c.functions_set:
		f_nodes.append(aux_tree.item)
	if node.left != None:
		function_nodes(node.left, aux_tree.left, f_nodes)
	if node.right != None:
		function_nodes(node.right, aux_tree.right, f_nodes)

# Select the nodes from a tree which have only terminals
def terminal_nodes(node, aux_tree, t_nodes):
	if node.item not in c.functions_set:
		t_nodes.append(aux_tree.item)
	if node.left != None:
		terminal_nodes(node.left, aux_tree.left, t_nodes)
	if node.right != None:
		terminal_nodes(node.right, aux_tree.right, t_nodes)

# Find the mutation_point in the auxiliar tree (node_copy) and mutates the sub-tree.
def mutate(node, node_copy, mutation_point, m_type, find):
	if not find:
		if node.left != None:
			if node_copy.left.item == mutation_point:
				find = True
				if m_type == 1:
					if node.left.item not in c.functions_set:
						copy_set = c.terminals_set[:]
						if node.left.item in c.variables_set:
							del copy_set[copy_set.index(node.left.item)]
						node.left.item = (c.random.sample(copy_set, 1))[0]
						if node.left.item == 'num':
							node.left.item = c.random.uniform(c.MIN, c.MAX)
					elif node.left.item in c.function_for_one_terminal: # It's a function
						copy_set = c.function_for_one_terminal[:]
						del copy_set[copy_set.index(node.left.item)]
						if len(copy_set) == 0:
							node.left.item = (c.random.sample(c.functions_for_two_terminals, 1))[0]
							node.left.right = c.Node(c.random_terminal(), level=node.left.left.level)
							if node.left.right.item == 'num':
								node.left.right.item = c.random.uniform(c.MIN, c.MAX)
						else:
							node.left.item = (c.random.sample(copy_set, 1))[0]
					else:	
						copy_set = c.functions_for_two_terminals[:]
						del copy_set[copy_set.index(node.left.item)]
						node.left.item = (c.random.sample(copy_set, 1))[0]
				elif m_type == 2: # Expansion
					method = c.random.randint(0,1) # 1 -> Grow; 0 -> Full
					d = c.random.randint(1, (c.MAX_DEPTH-node.left.level+1))
					if method == 1:
						node.left = pop.grow(d, [0])
					else:
						node.left = pop.full(d, [0])					
				else: # Reduction					
					node.left.item = (c.random.sample(c.terminals_set, 1))[0]
					if node.left.item == 'num':
						node.left.item = c.random.uniform(c.MIN, c.MAX)
					node.left.left, node.left.right = None, None
			else:
				mutate(node.left, node_copy.left, mutation_point, m_type, find)

		if node.right != None:
			if node_copy.right.item == mutation_point:
				find = True
				if m_type == 1:
					if node.right.item not in c.functions_set:
						copy_set = c.terminals_set[:]
						if node.right.item in c.variables_set:
							del copy_set[copy_set.index(node.right.item)]
						node.right.item = (c.random.sample(copy_set, 1))[0]
						if node.right.item == 'num':
							node.right.item = c.random.uniform(c.MIN, c.MAX)
					else: # It's a function
						if node.right.item in c.function_for_one_terminal:
							copy_set = c.function_for_one_terminal[:]
							del copy_set[copy_set.index(node.right.item)]
							if len(copy_set) == 0:
								node.right.item = (c.random.sample(c.functions_for_two_terminals, 1))[0]
								node.right.right = c.Node(c.random_terminal(), level=node.right.left.level)
								if node.right.right.item == 'num':
									node.right.right.item = c.random.uniform(c.MIN, c.MAX)
							else:
								node.right.item = (c.random.sample(copy_set, 1))[0]
						else:	
							copy_set = c.functions_for_two_terminals[:]
							del copy_set[copy_set.index(node.right.item)]
							node.right.item = (c.random.sample(copy_set, 1))[0]
				elif m_type == 2: # Expansion
					method = c.random.randint(0,1) # 1 -> Grow; 0 -> Full
					d = c.random.randint(1, (c.MAX_DEPTH-node.right.level+1))
					if method == 1:
						node.right = pop.grow(d, [0])
					else:
						node.right = pop.full(d, [0])					
				else: # Reduction
					node.right.item = (c.random.sample(c.terminals_set, 1))[0]
					if node.right.item == 'num':
						node.right.item = c.random.uniform(c.MIN, c.MAX)
					node.right.left, node.right.right = None, None
			else:
				mutate(node.right, node_copy.right, mutation_point, m_type, find)